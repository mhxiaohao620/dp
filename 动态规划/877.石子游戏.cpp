#include<iostream>
using namespace std;
#include<vector>
//方法一：动态规划
//注意动态规划的思想是希望状态连续，即上一个状态和下一个状态之间有关系且连续
//这里取石子的状态也是连续的，或者说是若干个子问题，需要合并为大问题
//涉及到最多的，最少的，一般是用动态规划/贪心
//
//这道题其实是区间dp，初次接触区间dp，需要取任意区间的子问题结果的dp就是区间dp
//1.dp数组含义
//设dp[i][j]为区间[i,j]上，先手玩家与后手玩家所拿石子的最大差值，那么f[0][n-1]就是考虑整个石子堆区间的结果，即最后判断的依据
//2.确定递推公式
//(1）先手从左端取石子，则当前取石子的玩家手中有了piles[i]，那么可选区间变为[i+1][j]，且后手变为先手了，则dp[i+1][j]为前一个后手（当前为先手）比前一个先手多的石子数
//那么先手与后手所拿石子的差值为piles[i]-dp[i+1][j]
//(2)先手从右端取，则先手玩家有了piles[j]，可选区间变为[i][j-1]，且后手变为先手，则dp[i][j-1]为前一个后手（当前为先手）比前一个先手多的石子数
//那么先后手之间所拿石子的差值为piles[j]-dp[i][j-1]
//因此dp[i][j]=max(piles[i]-dp[i+1][j],piles[j]-dp[i][j-1]);
//3.dp数组初始化
//当i>j时，不构成区间，因此dp[i][j]=0; 当i==j时，则先手玩家先拿，且只能拿piles[i]石子，因此dp[i][i]=piles[i];
//4.遍历顺序
//对于区间dp，i要从大到小遍历，j从i开始向后遍历，这样才能把大区间分成小区间，从小区间开始判断，因此，i要在外层循环
//5.debug
//
//空间优化：因为考虑到dp[i][j]之和当前i行与i+1行相关，因此可以优化为一维数组
//
//方法二，数学
//由于石子有偶数堆，所以石子堆的下标有奇数和偶数，且每次的两种选择一个是奇数下标一个是偶数下标，而先手可以先选择
//如果先手先选择奇数下标，那么后手只能选偶数的，如果先手选偶数，后者只能选择奇数，即只需要判断偶数下标的石子数总和与奇数下标的石子数总和哪个大
//根据题目条件没有平局，则总有一个是大的，因此先手只需要选择大的下标一直选即可

class Solution
{
public:
	bool stoneGame(vector<int>& piles)
	{
		int n = piles.size();
		vector<vector<int>>dp(n, vector<int>(n));
		//初始化
		for (int i = 0; i < n; ++i)
		{
			dp[i][i] = piles[i];
		}
		for (int i = n - 2; i >= 0; --i)
		{
			for (int j = i + 1; j < n; ++j)
			{
				dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
			}
		}
		return dp[0][n - 1] > 0;

		/*vector<int>dp(n);
		for (int j = 0; j < n; ++j)
		{
			dp[j] = piles[j];
		}
		for (int i = n - 1; i >= 0; --i)
		{
			for (int j = i + 1; j < n; ++j)
			{
				dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1]);
			}
		}
		return dp[n - 1] > 0;*/

		//return true;
	}
};